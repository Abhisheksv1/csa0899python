
ASSIGNMENT1.TXT
def get_weather(api_key, location):
    conn = http.client.HTTPConnection("api.openweathermap.org")
    conn.request("GET", f"/data/2.5/weather?q={location}&appid={api_key}&units=metric")
    response = conn.getresponse()
    if response.status == 200:
        data = json.loads(response.read().decode("utf-8"))
        return {
            "temperature": data["main"]["temp"],
            "weather_condition": data["weather"][0]["description"],
            "humidity": data["main"]["humidity"],
            "wind_speed": data["wind"]["speed"]
        }
    else:
        return {"error": "Failed to retrieve weather data"}

def display_weather(weather_data):
    print("Current Weather Data:")
    print(f"Temperature: {weather_data['temperature']}Â°C")
    print(f"Weather Condition: {weather_data['weather_condition']}")
    print(f"Humidity: {weather_data['humidity']}%")
    print(f"Wind Speed: {weather_data['wind_speed']} m/s")

def main():
    api_key = input("Enter your OpenWeatherMap API key: ")
    location = input("Enter the location (city name): ")
    weather_data = get_weather(api_key, location)
    if "error" in weather_data:
        print(weather_data["error"])
    else:
        display_weather(weather_data)

if __name__ == "__main__":
    main()

ASSIGNMENT-2.txt

    def _init_(self, product_id, name, current_stock, reorder_point, reorder_quantity):
        self.product_id = product_id
        self.name = name
        self.current_stock = current_stock
        self.reorder_point = reorder_point
        self.reorder_quantity = reorder_quantity

class Warehouse:
    def _init_(self, warehouse_id, location):
        self.warehouse_id = warehouse_id
        self.location = location
        self.products = []

def track_inventory(products):
    for product in products:
        if product.current_stock < product.reorder_point:
            print(f"Alert: {product.name} is below the reorder point. Current stock: {product.current_stock}")
            recommend_reorder(product)

def recommend_reorder(product):
    new_stock = product.current_stock + product.reorder_quantity
    print(f"Recommended reorder for {product.name}: {product.reorder_quantity} units. New stock level: {new_stock}")

def calculate_reorder_point(historical_sales, lead_time, desired_service_level):
    # Implement algorithms to calculate the optimal reorder point
    # based on historical sales data, lead time, and desired service level
    pass

def calculate_reorder_quantity(historical_sales, lead_time, holding_cost, ordering_cost):
    # Implement algorithms to calculate the optimal reorder quantity
    # based on historical sales data, lead time, holding cost, and ordering cost
    pass

def generate_inventory_report(products):
    # Generate reports on inventory turnover rates, stockout occurrences, and cost implications of overstock situations
    pass

def user_interface():
    # Define sample products and warehouses
    product1 = Product(1, "Product A", 50, 20, 30)
    product2 = Product(2, "Product B", 15, 10, 25)
    warehouse1 = Warehouse(1, "Warehouse A")
    warehouse1.products = [product1, product2]

    while True:
        user_input = input("Enter a product ID or name (or 'exit' to quit): ")
        if user_input.lower() == "exit":
            break

        # Look up the product and display current stock, reorder recommendations, and historical data
        for product in warehouse1.products:
            if str(product.product_id) == user_input or product.name.lower() == user_input.lower():
                print(f"Product: {product.name}")
                print(f"Current Stock: {product.current_stock}")
                recommend_reorder(product)
                # Display historical data
                break
        else:
            print("Product not found.")

ASSIGNMENT-3.txt

import socket
import time
import json

def get_user_input():
    start_point = input("Enter starting point: ")
    destination = input("Enter destination: ")
    return start_point, destination

def send_api_request(start_point, destination, api_key):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect(("maps.googleapis.com", 443))
    request = f"GET /maps/api/directions/json?origin={start_point}&destination={destination}&key={api_key}&traffic_model=best_guess HTTP/1.1\r\nHost: maps.googleapis.com\r\n\r\n"
    sock.sendall(request.encode())
    response = b""
    while True:
        data = sock.recv(1024)
        if not data:
            break
        response += data
    sock.close()

    # Split the response into headers and body
    response_parts = response.decode().split("\r\n\r\n", 1)

    # Check the response status code
    status_code = int(response_parts[0].split("\r\n")[0].split(" ")[1])
    if status_code == 200:
        return json.loads(response_parts[1])
    else:
        raise Exception(f"API request failed with status code {status_code}")

def display_traffic_data(traffic_data):
    if "routes" in traffic_data:
        for route in traffic_data["routes"]:
            for leg in route["legs"]:
                print(f"Route: {leg['start_address']} to {leg['end_address']}")
                print(f"Estimated Travel Time: {leg['duration']['text']}")
                for step in leg["steps"]:
                    print(f"Step: {step['html_instructions']}")
                    if "traffic_speed_entry" in step:
                        print(f"Traffic Speed: {step['traffic_speed_entry']['speed']} km/h")
                        if step['traffic_speed_entry']['congestion'] == True:
                            print("Congestion Detected")
                    print()
    else:
        print("Error: Unable to fetch traffic data.")

def main():
    api_key = "YOUR_API_KEY"

    while True:
        start_point, destination = get_user_input()
        try:
            traffic_data = send_api_request(start_point, destination, api_key)
            display_traffic_data(traffic_data)
        except Exception as e:
            print(f"Error: {e}")
        print(f"Last updated: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print()
        input("Press Enter to continue...")

if __name__ == "__main__":
    main()
  
ASSIGNMENT-4.txt

import urllib.request
import json

# Function to get COVID-19 statistics from disease.sh API
def get_covid_data(location):
    # Set the API endpoint and parameters
    url = f"https://disease.sh/v3/covid-19/countries/{location}"

    # Send a GET request to the API
    with urllib.request.urlopen(url) as response:
        # Load the JSON response
        data = json.load(response)

        # Extract the relevant COVID-19 data
        cases = data["cases"]
        recoveries = data["recovered"]
        deaths = data["deaths"]

        # Return the COVID-19 data as a dictionary
        return {"cases": cases, "recoveries": recoveries, "deaths": deaths}

# Function to display the COVID-19 statistics
def display_covid_data(covid_data):
    # Print the COVID-19 data in a readable format
    print("Current COVID-19 Statistics:")
    print(f"Cases: {covid_data['cases']}")
    print(f"Recoveries: {covid_data['recoveries']}")
    print(f"Deaths: {covid_data['deaths']}")

# Main function to run the program
def main():
    # Get the location from the user
    location = input("Enter the country, state, or city: ")

    # Get the COVID-19 data
    try:
        covid_data = get_covid_data(location)
    except urllib.error.HTTPError:
        print("Failed to retrieve COVID-19 data. Please check the location and try again.")
        return

    # Display the COVID-19 data
    display_covid_data(covid_data)

# Run the main function
if __name__ == "__main__":
    main()
